// 008_Operator.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>
using namespace std;

int main()
{
    // 코드 읽기 규칙
    // 1. 기본적으로는 위에서부터 아래로 읽는다.
    // 2. 오른쪽에서 왼쪽으로 읽는다. 예외 : ()가 있으면 ()부터
    //  

    int Left = 3;
    // 오른쪽에서 왼쪽으로 읽는다.
    // 0. 3을 준비한다.
    // 1. 대입연산자를 준비한다.
    // 2. Left를 만든다.
    // 3. Left에 대입한다.

    int Right = 5;
    int Result = 0;

    // 변수를 사용해서 특정한 결과를 리턴하는 것을 연산자라고 한다.
    // 이때 변수가 1개 필요하면 -> 단항 연산자
    // !Left;

    // 변수가 2개 필요하면 -> 이항 연산자
    // Left + Right;

    // 변수가 3개 필요하면 -> 삼항 연산자
    // Result = Right > 0 ? Right : Left

    // 연산자는 개념적으로 함수와 같다. (연산자 == 함수 == 행동)
    // 연산자는 무조건 하나의 자료형으로 통일된다. (정수 + 정수 = 정수)

    // 연산자의 종류는 다음과 같다
    // 1. 산술 연산자 (+ - * / %)
    // 변수의 앞에 자료형이 붙어있으면 -> 변수를 만들겠다.
    // 변수를 사용할 때는 자료형을 생략하고 사용한다.
    // 오른쪽의 메모리를 왼쪽의 메모리로 복사한다.
    Left = 3;
    // [0][0][0][0] [][][][] [0][1][0][1] [][][][] <- 램의 어딘가
    //     Left                  Right
    // [0][1][0][1] [][][][] [0][1][0][1] [][][][]
    //     Left                  Right

    Result = Left + Right;
    Result = Left - Right;
    Result = Left * Right;
    Result = Left = Right;

    // 2. 비교 연산자
    // 비교연산자는 논리형(bool)을 리턴한다.
    bool bResult = true;
    // 논리형 상수에는 true, false가 있다.

    bResult = Left == Right;
    // Left와 Right가 같으면 true, 다르면 false를 반환함
    bResult = Left != Right;
    bResult = Left > Right;
    bResult = Left < Right;
    bResult = Left >= Right;
    bResult = Left <= Right;


    // 3. 논리 연산자
    // 논리 연산자를 이해하려면 참(true)과 거짓(false)에 대해 이해해야한다.
    // 이걸 이해하려면 비트단위로 자료형을 바라볼수 있어야 한다.
    // 모든 값은 논리형이 될 수 있다.
    // int 4바이트 정수형
    // 00000000 00000000 00000000 00000000
    // C++에서 참과 거짓은 아래와 같이 표현되기 때문이다.
    // 참 : 모든 비트 중 단 1개라도 1이 있으면 참. (0이 아닌 수)
    // 거짓 : 모든 비트가 0이어면 거짓. (0)

    bResult = !Left;
    // 오른쪽 메모리가 true라면 false를 false라면 true를 리턴
    bResult = Left && Right;
    bResult = Left || Right;


    // 4. 비트 연산자
    // 4바이트 정수 int는 32비트를 가지고 있음.
    //                                   8421 
    Left = 0b00000000000000000000000000000000;
    Left = ~0b00000000000000000000000000000000;
    //      0b11111111111111111111111111111111;

    // 가장 앞의 비트가 1이면 음수이다.
    // 그랬더니 문제가 생겼다. 0의 -0이라는게 없다는 것이다.
    // -> 2의 보수법을 사용하기로 했다.
    // 맨 앞의 비트가 1이되서 음수가 되면 양수표현식을 뒤집자
    // 모든 값이 1로 채워졌을때를 -1로 보고
    // -2를 만들고 싶으면 그 -1인 상태에서
    // 0인 곳의 값을 음수로 더하기로 했다.
    // 
    Left = 0b11111111111111111111111111111111;
    //       |
    //    부호비트
    // 1. 32번째 비트(부호비트)를 확인한다.
    // 2. 0이다 -> 그냥 양수표현식으로 계산.
    // 3. 1이다 -> 그럼 음수로 보고 모든 비트가 1일때를 -1로 본다.
    //             그리고 0인 부분의 숫자를 음수로 더해준다.
    //             0b11111111111111111111111111111101
    //             -> -1 + (-2) = -3
    //
    Result = Left & Right;
    Result = Left | Right;
    Result = Left << 2;
    Result = Left >> 2;

    // 다음과 같은 경우에 사용할 수 있다.
    // 다수 or 특정 퀘스트 수행여부 확인

    // 2023.12.13 과제
    // 비트단위 연산자를 사용해서 int의 최대값을 만들어라
    // 0b01111111111111111111111111111111

    // 
    // 
    // 5. 복합 할당 연산자
    // 6. 멤버, 포인터 연산자
    // 7. 기타 연산자
    // 

}